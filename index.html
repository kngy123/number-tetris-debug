<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°å­—ãƒ†ãƒˆãƒªã‚¹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .game-container {
            touch-action: manipulation;
        }
        .block {
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-sizing: border-box;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
        }
        .controls button {
            touch-action: manipulation;
        }
        @keyframes flash {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        .flash {
            animation: flash 0.3s 2;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div class="text-center mb-4">
        <h1 class="text-3xl font-bold mb-2">æ•°å­—ãƒ†ãƒˆãƒªã‚¹</h1>
        <p class="text-gray-300 mb-4">éš£ã‚Šåˆã†æ•°å­—ã®åˆè¨ˆãŒ10ã«ãªã‚‹ã¨æ¶ˆãˆã¾ã™</p>
        <div class="flex justify-between w-full max-w-md mx-auto mb-4">
            <div class="text-left">
                <p>ã‚¹ã‚³ã‚¢: <span id="score">0</span></p>
                <p>ãƒ¬ãƒ™ãƒ«: <span id="level">1</span></p>
            </div>
            <div class="text-right">
                <p>æ¬¡ã®ãƒŸãƒ:</p>
                <div id="next-piece" class="inline-block"></div>
            </div>
        </div>
    </div>

    <div class="relative game-container bg-gray-800 border-2 border-gray-700 mb-4" id="game-board">
        <!-- ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã¯JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
    </div>

    <div class="controls flex flex-col items-center w-full max-w-md">
        <div class="grid grid-cols-3 gap-2 mb-4 w-full">
            <button id="left" class="bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg">â†</button>
            <button id="rotate" class="bg-purple-600 hover:bg-purple-700 text-white py-3 rounded-lg">å›è»¢</button>
            <button id="right" class="bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg">â†’</button>
        </div>
        <div class="w-full">
            <button id="down" class="bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg w-full mb-2">â†“ é€Ÿãè½ä¸‹</button>
            <button id="drop" class="bg-red-600 hover:bg-red-700 text-white py-3 rounded-lg w-full">ä¸€æ°—ã«è½ä¸‹</button>
        </div>
    </div>

    <div id="game-over" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg text-center max-w-md w-full">
            <h2 class="text-2xl font-bold mb-4">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <p class="mb-4">æœ€çµ‚ã‚¹ã‚³ã‚¢: <span id="final-score">0</span></p>
            <button id="restart" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-6 rounded-lg">ã‚‚ã†ä¸€åº¦éŠã¶</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ã‚²ãƒ¼ãƒ è¨­å®š
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 30;
            const COLORS = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', 
                '#536DFE', '#448AFF', '#40C4FF', '#18FFFF', 
                '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41', 
                '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
            ];
            
            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
            let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            let currentPiece = null;
            let nextPiece = null;
            let score = 0;
            let level = 1;
            let gameOver = false;
            let dropInterval = 1000; // ãƒŸãƒªç§’
            let dropStart;
            let lastDrop = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            let isProcessing = false; // å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°
            
            // DOMè¦ç´ 
            const gameBoard = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const nextPieceElement = document.getElementById('next-piece');
            const gameOverElement = document.getElementById('game-over');
            const finalScoreElement = document.getElementById('final-score');
            
            // ãƒœãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºè¨­å®š
            gameBoard.style.width = `${COLS * BLOCK_SIZE}px`;
            gameBoard.style.height = `${ROWS * BLOCK_SIZE}px`;
            
            // ãƒŸãƒã®å½¢çŠ¶ã¨æ•°å­—
            const PIECES = [
                { 
                    shape: [[1, 1, 1, 1]], 
                    numbers: [1, 2, 3, 4],
                    name: 'I' 
                }, // I
                { 
                    shape: [[1, 1], [1, 1]], 
                    numbers: [5, 6, 7, 8],
                    name: 'O' 
                }, // O
                { 
                    shape: [[0, 1, 0], [1, 1, 1]], 
                    numbers: [9, 0, 1, 2],
                    name: 'T' 
                }, // T
                { 
                    shape: [[1, 1, 0], [0, 1, 1]], 
                    numbers: [3, 4, 5, 6],
                    name: 'S' 
                }, // S
                { 
                    shape: [[0, 1, 1], [1, 1, 0]], 
                    numbers: [7, 8, 9, 0],
                    name: 'Z' 
                }, // Z
                { 
                    shape: [[1, 0, 0], [1, 1, 1]], 
                    numbers: [1, 2, 3, 4],
                    name: 'L' 
                }, // L
                { 
                    shape: [[0, 0, 1], [1, 1, 1]], 
                    numbers: [5, 6, 7, 8],
                    name: 'J' 
                }  // J
            ];
            
            // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
            function init() {
                board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                score = 0;
                level = 1;
                gameOver = false;
                isProcessing = false;
                dropInterval = 1000;
                updateScore();
                generatePiece();
                drawBoard();
                dropStart = Date.now();
                lastDrop = dropStart;
                gameOverElement.classList.add('hidden');
                
                // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—é–‹å§‹
                requestAnimationFrame(gameLoop);
            }
            
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
            function gameLoop(timestamp) {
                if (gameOver) return;
                
                const now = Date.now();
                const delta = now - lastDrop;
                
                if (delta > dropInterval && !isProcessing) {
                    moveDown();
                    lastDrop = now - (delta % dropInterval);
                }
                
                drawBoard();
                requestAnimationFrame(gameLoop);
            }
            
            // æ–°ã—ã„ãƒŸãƒã‚’ç”Ÿæˆ
            function generatePiece() {
                if (!nextPiece) {
                    nextPiece = getRandomPiece();
                }
                
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                drawNextPiece();
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒã‚§ãƒƒã‚¯
                if (collision(0, 0)) {
                    gameOver = true;
                    finalScoreElement.textContent = score;
                    gameOverElement.classList.remove('hidden');
                }
            }
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒŸãƒã‚’å–å¾—
            function getRandomPiece() {
                const randomIndex = Math.floor(Math.random() * PIECES.length);
                const piece = PIECES[randomIndex];
                
                // æ•°å­—é…åˆ—ã‚’æ­£ã—ãã‚³ãƒ”ãƒ¼
                const numbers = [...piece.numbers].map(num => {
                    // NaNã‚’é˜²ããŸã‚ã«æ•°å€¤ã«å¤‰æ›
                    const n = Number(num);
                    return isNaN(n) ? 0 : n;
                });
                
                // ãƒŸãƒã®ä½ç½®ã¨å›è»¢çŠ¶æ…‹
                const newPiece = {
                    shape: piece.shape,
                    numbers: numbers,
                    x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                    y: 0,
                    rotation: 0,
                    name: piece.name
                };
                
                return newPiece;
            }
            
            // è¡çªåˆ¤å®š
            function collision(offsetX, offsetY, newShape = null) {
                const shape = newShape || currentPiece.shape;
                
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const newX = currentPiece.x + x + offsetX;
                            const newY = currentPiece.y + y + offsetY;
                            
                            if (
                                newX < 0 || 
                                newX >= COLS || 
                                newY >= ROWS ||
                                (newY >= 0 && board[newY][newX])
                            ) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // ãƒŸãƒã‚’ãƒœãƒ¼ãƒ‰ã«å›ºå®š
            function lockPiece() {
                if (isProcessing) return;
                isProcessing = true;
                
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            const boardX = currentPiece.x + x;
                            
                            if (boardY >= 0) {
                                // æ•°å­—ã‚’ä¿å­˜ (0-9ã®ç¯„å›²ã§å¾ªç’°)
                                const numIndex = y * currentPiece.shape[0].length + x;
                                let num = currentPiece.numbers[numIndex] % 10;
                                // NaNã‚’é˜²ã
                                num = isNaN(num) ? 0 : num;
                                // ãƒ–ãƒ­ãƒƒã‚¯ã®DOMè¦ç´ ã‚’ä½œæˆã—ã€ãƒœãƒ¼ãƒ‰ã«ä¿å­˜
                                const blockElement = document.createElement('div');
                                blockElement.className = 'block';
                                blockElement.style.width = `${BLOCK_SIZE}px`;
                                blockElement.style.height = `${BLOCK_SIZE}px`;
                                blockElement.style.left = `${boardX * BLOCK_SIZE}px`;
                                blockElement.style.top = `${boardY * BLOCK_SIZE}px`;
                                blockElement.style.backgroundColor = COLORS[num];
                                blockElement.textContent = num;
                                gameBoard.appendChild(blockElement);

                                board[boardY][boardX] = {
                                    color: COLORS[num],
                                    number: num,
                                    element: blockElement // DOMè¦ç´ ã‚’ä¿å­˜
                                };
                            }
                        }
                    }
                }
                
                // æ¨ªä¸€åˆ—ãŒæƒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                checkFullRows();
                
                // æ¶ˆå»å¯èƒ½ãªãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
                checkMatches().then(() => {
                    // æ–°ã—ã„ãƒŸãƒã‚’ç”Ÿæˆ
                    generatePiece();
                    isProcessing = false;
                });
            }
            
            // æ¨ªä¸€åˆ—ãŒæƒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            function checkFullRows() {
                let rowsToClear = [];
                
                // ä¸‹ã‹ã‚‰ä¸Šã«ãƒã‚§ãƒƒã‚¯
                for (let y = ROWS - 1; y >= 0; y--) {
                    let rowFull = true;
                    for (let x = 0; x < COLS; x++) {
                        if (!board[y][x]) {
                            rowFull = false;
                            break;
                        }
                    }
                    
                    if (rowFull) {
                        rowsToClear.push(y);
                    }
                }
                
                if (rowsToClear.length > 0) {
                    // è¡Œã‚’æ¶ˆå»
                    for (const row of rowsToClear) {
                        for (let x = 0; x < COLS; x++) {
                            board[row][x] = 0;
                        }
                    }
                    
                    // ã‚¹ã‚³ã‚¢åŠ ç®— (1è¡Œ100ç‚¹ã€2è¡Œ300ç‚¹ã€3è¡Œ500ç‚¹ã€4è¡Œ800ç‚¹)
                    const linePoints = [0, 100, 300, 500, 800];
                    score += linePoints[rowsToClear.length] * level;
                    updateScore();
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’è½ä¸‹ã•ã›ã‚‹
                    dropBlocksAfterClear(rowsToClear);
                    
                    // æ¶ˆãˆãŸè¡Œã‚’ç‚¹æ»…ã•ã›ã‚‹
                    flashRows(rowsToClear);
                }
            }
            
            // è¡Œã‚’æ¶ˆã—ãŸå¾Œã«ãƒ–ãƒ­ãƒƒã‚¯ã‚’è½ä¸‹ã•ã›ã‚‹
            function dropBlocksAfterClear(clearedRows) {
                // æ¶ˆå»ã•ã‚ŒãŸè¡Œã‚’ã‚½ãƒ¼ãƒˆ
                clearedRows.sort((a, b) => a - b);
                
                // å„æ¶ˆå»è¡Œã«å¯¾ã—ã¦ã€ãã®ä¸Šã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è½ä¸‹ã•ã›ã‚‹
                for (const row of clearedRows) {
                    // ä¸Šã®è¡Œã‚’1ã¤ãšã¤ä¸‹ã«ç§»å‹•
                    for (let y = row; y > 0; y--) {
                        for (let x = 0; x < COLS; x++) {
                            board[y][x] = board[y-1][x];
                        }
                    }
                    
                    // æœ€ä¸Šè¡Œã‚’ç©ºã«ã™ã‚‹
                    for (let x = 0; x < COLS; x++) {
                        board[0][x] = 0;
                    }
                }
            }
            
            // æ¶ˆãˆãŸè¡Œã‚’ç‚¹æ»…ã•ã›ã‚‹
            function flashRows(rows) {
                // ä¸€æ™‚çš„ã«ãƒœãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼
                const tempBoard = JSON.parse(JSON.stringify(board));
                
                // æ¶ˆãˆãŸè¡Œã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤º
                for (const row of rows) {
                    for (let x = 0; x < COLS; x++) {
                        board[row][x] = 0;
                    }
                }
                
                // ãƒœãƒ¼ãƒ‰ã‚’å†æç”»
                drawBoard();
                
                // 300mså¾Œã«å…ƒã«æˆ»ã™
                setTimeout(() => {
                    // æ¶ˆãˆãŸè¡Œã¯ãã®ã¾ã¾ç©ºã«ã™ã‚‹
                    drawBoard();
                }, 300);
            }
            
            // åˆè¨ˆãŒ10ã«ãªã‚‹éš£æ¥ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
            function checkMatches() {
                return new Promise(resolve => {
                const directions = [
                    { dx: 1, dy: 0 },  // å³
                    { dx: 0, dy: 1 },  // ä¸‹
                    { dx: -1, dy: 0 }, // å·¦
                    { dx: 0, dy: -1 }  // ä¸Š
                ];
                
                let matchedBlocks = [];
                let hasMatches = false;
                
                // ã™ã¹ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const currentNum = board[y][x].number;
                            
                            // 4æ–¹å‘ã‚’ãƒã‚§ãƒƒã‚¯
                            for (const dir of directions) {
                                const nx = x + dir.dx;
                                const ny = y + dir.dy;
                                
                                if (
                                    nx >= 0 && nx < COLS && 
                                    ny >= 0 && ny < ROWS && 
                                    board[ny][nx]
                                ) {
                                    const neighborNum = board[ny][nx].number;
                                    
                                    if ((currentNum + neighborNum) === 10) {
                                        // ãƒãƒƒãƒã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’è¨˜éŒ² (é‡è¤‡é˜²æ­¢)
                                        if (!matchedBlocks.some(b => b.x === x && b.y === y)) {
                                            matchedBlocks.push({ x, y });
                                        }
                                        if (!matchedBlocks.some(b => b.x === nx && b.y === ny)) {
                                            matchedBlocks.push({ x: nx, y: ny });
                                        }
                                        hasMatches = true;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (hasMatches) {
                    // ãƒãƒƒãƒã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¶ˆå»
                    // flashBlockså†…ã§DOMè¦ç´ ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ãƒœãƒ¼ãƒ‰ã‹ã‚‰å‰Šé™¤ã—ãªã„
                    
                    // ã‚¹ã‚³ã‚¢åŠ ç®—
                    score += matchedBlocks.length * 10 * level;
                    updateScore();
                    
                    // ãƒãƒƒãƒã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’ç‚¹æ»…ã•ã›ã‚‹
                    flashBlocks(matchedBlocks).then(() => {
                        // å®Ÿéš›ã«ãƒœãƒ¼ãƒ‰ã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤
                        for (const block of matchedBlocks) {
                            board[block.y][block.x] = 0;
                        }
                        
                        // ãƒ–ãƒ­ãƒƒã‚¯ã‚’è½ä¸‹ã•ã›ã‚‹
                        dropBlocks();
                        
                        // è½ä¸‹å¾Œã®ãƒœãƒ¼ãƒ‰ã‚’å†æç”»
                        drawBoard();
                        
                        // å†å¸°çš„ã«ãƒãƒƒãƒã‚’ãƒã‚§ãƒƒã‚¯
                        checkMatches().then(resolve);
                    });
                } else {
                    resolve();
                }
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’è½ä¸‹ã•ã›ã‚‹
            function dropBlocks() {
                // ä¸‹ã‹ã‚‰ä¸Šã«ã‚¹ã‚­ãƒ£ãƒ³
                for (let y = ROWS - 1; y >= 0; y--) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x] === 0) {
                            // ä¸Šã®è¡Œã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¢ã—ã¦è½ä¸‹ã•ã›ã‚‹
                            for (let ny = y - 1; ny >= 0; ny--) {
                                if (board[ny][x]) {
                                    board[y][x] = board[ny][x];
                                    board[ny][x] = 0;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            // ãƒãƒƒãƒã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’ç‚¹æ»…ã•ã›ã‚‹
            function flashBlocks(blocks) {
                return new Promise(resolve => {
                // ä¸€æ™‚çš„ã«ãƒœãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼
                const tempBoard = JSON.parse(JSON.stringify(board));
                
                // ãƒãƒƒãƒã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤º
                for (const block of blocks) {
                    if (board[block.y] && board[block.y][block.x]) {
                        board[block.y][block.x] = 0;
                    }
                }
                
                // ãƒœãƒ¼ãƒ‰ã‚’å†æç”»
                drawBoard();
                
                // 300mså¾Œã«å…ƒã«æˆ»ã™
                setTimeout(() => {
                    // ãƒãƒƒãƒã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã®DOMè¦ç´ ã‚’å‰Šé™¤
                    for (const block of blocks) {
                        const element = board[block.y][block.x].element;
                        if (element) {
                            element.remove();
                        }
                    }
                    // ãƒœãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ã¯checkMatchesã§å‰Šé™¤ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯DOMè¦ç´ ã®ã¿å‰Šé™¤
                    resolve();
                }, 300);
            }
            
            // ãƒŸãƒã‚’ç§»å‹•
            function movePiece(offsetX, offsetY) {
                if (gameOver || isProcessing) return false;
                
                if (!collision(offsetX, offsetY)) {
                    currentPiece.x += offsetX;
                    currentPiece.y += offsetY;
                    return true;
                }
                return false;
            }
            
            // ãƒŸãƒã‚’å›è»¢
            function rotatePiece() {
                if (gameOver || isProcessing) return;

                const originalShape = currentPiece.shape;
                
                // Oãƒ–ãƒ­ãƒƒã‚¯ï¼ˆæ­£æ–¹å½¢ï¼‰ã¯å›è»¢ã—ãªã„
                if (currentPiece.name === 'O') {
                    return;
                }

                // æ–°ã—ã„å½¢çŠ¶ã‚’è¨ˆç®— (æ™‚è¨ˆå›ã‚Šã«90åº¦å›è»¢)
                const rows = originalShape.length;
                const cols = originalShape[0].length;
                const newShape = Array(cols).fill().map(() => Array(rows).fill(0));

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        newShape[x][rows - 1 - y] = originalShape[y][x];
                    }
                }

                // è¡çªãƒã‚§ãƒƒã‚¯
                if (!collision(0, 0, newShape)) {
                    currentPiece.shape = newShape;
                    // æ•°å­—ã®å›è»¢ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
                    const originalNumbers = currentPiece.numbers;
                    const newNumbers = [];
                    
                    // å…ƒã®å½¢çŠ¶ã®ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã¨æ•°å­—ã®å¯¾å¿œã‚’ä¸€æ™‚çš„ã«ä¿æŒ
                    const blockData = [];
                    let numberIndex = 0;
                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            if (originalShape[y][x]) {
                                blockData.push({
                                    x: x,
                                    y: y,
                                    number: originalNumbers[numberIndex]
                                });
                                numberIndex++;
                            }
                        }
                    }
                    
                    // å›è»¢å¾Œã®æ–°ã—ã„åº§æ¨™ã‚’è¨ˆç®—ã—ã€æ•°å­—ã‚’æ–°ã—ã„é…åˆ—ã«æ ¼ç´
                    const newBlockData = blockData.map(data => {
                        // æ™‚è¨ˆå›ã‚Šã«90åº¦å›è»¢: (x, y) -> (rows - 1 - y, x)
                        const newX = rows - 1 - data.y;
                        const newY = data.x;
                        return {
                            x: newX,
                            y: newY,
                            number: data.number
                        };
                    });
                    
                    // æ–°ã—ã„å½¢çŠ¶ã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦æ–°ã—ã„æ•°å­—é…åˆ—ã‚’ä½œæˆ
                    const newRows = newShape.length;
                    const newCols = newShape[0].length;
                    
                    // æ–°ã—ã„å½¢çŠ¶ã®ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã«æ•°å­—ã‚’é…ç½®
                    let dataIndex = 0;
                    for (let y = 0; y < newRows; y++) {
                        for (let x = 0; x < newCols; x++) {
                            if (newShape[y][x]) {
                                // æ–°ã—ã„åº§æ¨™ (x, y) ã«å¯¾å¿œã™ã‚‹æ•°å­—ã‚’æ¢ã™
                                const found = newBlockData.find(d => d.x === x && d.y === y);
                                if (found) {
                                    newNumbers.push(found.number);
                                } else {
                                    // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã ãŒã€å¿µã®ãŸã‚0
                                    newNumbers.push(0);
                                }
                            }
                        }
                    }
                    
                    currentPiece.numbers = newNumbers;

                    // å£ã«ã‚ã‚Šè¾¼ã¾ãªã„ã‚ˆã†ã«èª¿æ•´
                    if (currentPiece.x < 0) currentPiece.x = 0;
                    if (currentPiece.x + newShape[0].length > COLS) {
                        currentPiece.x = COLS - newShape[0].length;
                    }
                }
            }
            
            // ä¸‹ã«ç§»å‹•
            function moveDown() {
                if (!movePiece(0, 1)) {
                    lockPiece();
                }
            }
            
            // ä¸€æ°—ã«è½ä¸‹
            function hardDrop() {
                if (gameOver || isProcessing) return;
                
                while (movePiece(0, 1)) {}
                lockPiece();
            }
            
            // ãƒœãƒ¼ãƒ‰ã‚’æç”»
            function drawBoard() {
                // ãƒœãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢
                gameBoard.innerHTML = '';
                
                // å›ºå®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const block = document.createElement('div');
                            block.className = 'block';
                            block.style.width = `${BLOCK_SIZE}px`;
                            block.style.height = `${BLOCK_SIZE}px`;
                            block.style.left = `${x * BLOCK_SIZE}px`;
                            block.style.top = `${y * BLOCK_SIZE}px`;
                            block.style.backgroundColor = board[y][x].color;
                            // NaNã‚’é˜²ã
                            const num = isNaN(board[y][x].number) ? 0 : board[y][x].number;
                            block.textContent = num;
                            gameBoard.appendChild(block);
                        }
                    }
                }
                
                // ç¾åœ¨ã®ãƒŸãƒã‚’æç”»
                if (currentPiece && !isProcessing) {
                    for (let y = 0; y < currentPiece.shape.length; y++) {
                        for (let x = 0; x < currentPiece.shape[y].length; x++) {
                            if (currentPiece.shape[y][x]) {
                                const blockY = currentPiece.y + y;
                                const blockX = currentPiece.x + x;
                                
                                if (blockY >= 0) {
                                    const numIndex = y * currentPiece.shape[0].length + x;
                                    let num = currentPiece.numbers[numIndex] % 10;
                                    // NaNã‚’é˜²ã
                                    num = isNaN(num) ? 0 : num;
                                    
                                    const block = document.createElement('div');
                                    block.className = 'block';
                                    block.style.width = `${BLOCK_SIZE}px`;
                                    block.style.height = `${BLOCK_SIZE}px`;
                                    block.style.left = `${blockX * BLOCK_SIZE}px`;
                                    block.style.top = `${blockY * BLOCK_SIZE}px`;
                                    block.style.backgroundColor = COLORS[num];
                                    block.style.opacity = '0.8';
                                    block.textContent = num;
                                    gameBoard.appendChild(block);
                                }
                            }
                        }
                    }
                }
            }
            
            // æ¬¡ã®ãƒŸãƒã‚’æç”»
            function drawNextPiece() {
                nextPieceElement.innerHTML = '';
                
                if (nextPiece) {
                    const container = document.createElement('div');
                    container.style.width = `${nextPiece.shape[0].length * BLOCK_SIZE / 2}px`;
                    container.style.height = `${nextPiece.shape.length * BLOCK_SIZE / 2}px`;
                    container.style.position = 'relative';
                    
                    for (let y = 0; y < nextPiece.shape.length; y++) {
                        for (let x = 0; x < nextPiece.shape[y].length; x++) {
                            if (nextPiece.shape[y][x]) {
                                const numIndex = y * nextPiece.shape[0].length + x;
                                let num = nextPiece.numbers[numIndex] % 10;
                                // NaNã‚’é˜²ã
                                num = isNaN(num) ? 0 : num;
                                
                                const block = document.createElement('div');
                                block.className = 'block';
                                block.style.width = `${BLOCK_SIZE / 2}px`;
                                block.style.height = `${BLOCK_SIZE / 2}px`;
                                block.style.left = `${x * BLOCK_SIZE / 2}px`;
                                block.style.top = `${y * BLOCK_SIZE / 2}px`;
                                block.style.backgroundColor = COLORS[num];
                                block.style.fontSize = '0.7rem';
                                block.textContent = num;
                                container.appendChild(block);
                            }
                        }
                    }
                    
                    nextPieceElement.appendChild(container);
                }
            }
            
            // ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°
            function updateScore() {
                scoreElement.textContent = score;
                levelElement.textContent = level;
                
                // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ— (ã‚¹ã‚³ã‚¢ãŒ500ç‚¹ã”ã¨ã«ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—)
                const newLevel = Math.floor(score / 500) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100); // ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã”ã¨ã«é€Ÿããªã‚‹
                }
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.getElementById('left').addEventListener('click', () => movePiece(-1, 0));
            document.getElementById('right').addEventListener('click', () => movePiece(1, 0));
            document.getElementById('down').addEventListener('click', () => moveDown());
            document.getElementById('rotate').addEventListener('click', () => rotatePiece());
            document.getElementById('drop').addEventListener('click', () => hardDrop());
            document.getElementById('restart').addEventListener('click', () => init());
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            document.addEventListener('keydown', (e) => {
                if (gameOver || isProcessing) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        break;
                    case 'ArrowDown':
                        moveDown();
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        break;
                    case ' ':
                        hardDrop();
                        break;
                }
            });
            
            // ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            gameBoard.addEventListener('touchstart', (e) => {
                if (gameOver || isProcessing) return;
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                e.preventDefault();
            }, { passive: false });
            
            gameBoard.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            gameBoard.addEventListener('touchend', (e) => {
                if (gameOver || isProcessing) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // ã‚¹ãƒ¯ã‚¤ãƒ—ã®é–¾å€¤
                const threshold = 30;
                
                // ã‚¹ãƒ¯ã‚¤ãƒ—ã®æ–¹å‘ã‚’åˆ¤å®š
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // æ¨ªæ–¹å‘ã®ã‚¹ãƒ¯ã‚¤ãƒ—
                    if (diffX > threshold) {
                        movePiece(1, 0); // å³
                    } else if (diffX < -threshold) {
                        movePiece(-1, 0); // å·¦
                    }
                } else {
                    // ç¸¦æ–¹å‘ã®ã‚¹ãƒ¯ã‚¤ãƒ—
                    if (diffY > threshold) {
                        hardDrop(); // ä¸‹ (ä¸€æ°—ã«è½ä¸‹)
                    } else if (diffY < -threshold) {
                        rotatePiece(); // ä¸Š (å›è»¢)
                    } else {
                        moveDown(); // ã‚¿ãƒƒãƒ— (é€šå¸¸è½ä¸‹)
                    }
                }
                
                e.preventDefault();
            }, { passive: false });
            
            // ã‚²ãƒ¼ãƒ é–‹å§‹
            init();
        });
    </script>
<p style="border-radius: 8px; text-align: center; font-size: 12px; color: #fff; margin-top: 16px;position: fixed; left: 8px; bottom: 8px; z-index: 10; background: rgba(0, 0, 0, 0.8); padding: 4px 8px;">Made with <img src="https://enzostvs-deepsite.hf.space/logo.svg" alt="DeepSite Logo" style="width: 16px; height: 16px; vertical-align: middle;display:inline-block;margin-right:3px;filter:brightness(0) invert(1);"><a href="https://enzostvs-deepsite.hf.space" style="color: #fff;text-decoration: underline;" target="_blank" >DeepSite</a> - ğŸ§¬ <a href="https://enzostvs-deepsite.hf.space?remix=kngy123/tetris-with-number" style="color: #fff;text-decoration: underline;" target="_blank" >Remix</a></p></body>
</html> 